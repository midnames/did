pragma language_version 0.17;

import CompactStandardLibrary;

export { Maybe, Either };

export sealed ledger controllerPublicKey: Bytes<32>;

export ledger active: Boolean;
export ledger keyRing: Map<Opaque<"string">, PublicKey>;
export ledger services: Map<Opaque<"string">, Service>;

export enum VerificationMethodType {
    Ed25519VerificationKey2020,
    JubJubVerificationKey2025,
}

export enum KeyType {
    EC, RSA, Oct
}

export enum CurveType {
    Ed25519, JubJub
}

export struct PublicKeyJwk {
    kty: KeyType,
    crv: CurveType,
    x: Field,
}

export struct PublicKeyMultibase {
    key: Opaque<"string">,
}

export struct PublicKey {
    id: Opaque<"string">,
    type: VerificationMethodType,
    publicKey: Either<PublicKeyJwk, PublicKeyMultibase>,
    allowedUsages: AllowedUsages,
}

export enum ActionType {
    Authentication,
    AssertionMethod,
    KeyAgreement,
    CapabilityInvocation,
    CapabilityDelegation,
}

export struct AllowedUsages {
    authentication: Boolean,
    assertionMethod: Boolean,
    keyAgreement: Boolean,
    capabilityInvocation: Boolean,
    capabilityDelegation: Boolean,
}

export struct Service {
    id: Opaque<"string">,
    type: Opaque<"string">,
    serviceEndpoint: Opaque<"string">,
}

witness localSecretKey(): Bytes<32>;

constructor() {
    controllerPublicKey = disclose(publicKey(localSecretKey()));
    active = true;
}

// Public

export enum OperationType{
    Deactivate,
    AddKey,
    RemoveKey,
    AddAllowedUsage,
    RemoveAllowedUsage,
    AddService,
    RemoveService,
}

export struct AddKeyArgs{
    key: PublicKey,
}

export struct RemoveKeyArgs {
    keyId: Opaque<"string">,
}

export struct AddAllowedUsageArgs {
    keyId: Opaque<"string">,
    actionType: ActionType,
}

export struct RemoveAllowedUsageArgs {
    keyId: Opaque<"string">,
    actionType: ActionType,
}

export struct AddServiceArgs {
    service: Service,
}

export struct RemoveServiceArgs {
    serviceId: Opaque<"string">,
}

export struct Operation {
    operationType: OperationType,
    addKeyArgs: Maybe<AddKeyArgs>,
    removeKeyArgs: Maybe<RemoveKeyArgs>,
    addAllowedUsageArgs: Maybe<AddAllowedUsageArgs>,
    removeAllowedUsageArgs: Maybe<RemoveAllowedUsageArgs>,
    addServiceArgs: Maybe<AddServiceArgs>,
    removeServiceArgs: Maybe<RemoveServiceArgs>,
}

export circuit applyOperation(operation: Operation): [] {
    assert(active, "DID is inactive");
    assert(controllerPublicKey == publicKey(localSecretKey()), "Only the Controller is allowed to update the DID");

    const d_operation = disclose(operation);

    if (d_operation.operationType == OperationType.Deactivate) {
        deactivate();
    } else if (d_operation.operationType == OperationType.AddKey) {
        addKey(d_operation.addKeyArgs.value.key);
    } else if (d_operation.operationType == OperationType.RemoveKey) {
        removeKey(d_operation.removeKeyArgs.value.keyId);
    } else if (d_operation.operationType == OperationType.AddAllowedUsage) {
        addAllowedUsage(d_operation.addAllowedUsageArgs.value.keyId, d_operation.addAllowedUsageArgs.value.actionType);
    } else if (d_operation.operationType == OperationType.RemoveAllowedUsage) {
        removeAllowedUsage(d_operation.removeAllowedUsageArgs.value.keyId, d_operation.removeAllowedUsageArgs.value.actionType);
    } else if (d_operation.operationType == OperationType.AddService) {
        addService(d_operation.addServiceArgs.value.service);
    } else if (d_operation.operationType == OperationType.RemoveService) {
        removeService(d_operation.removeServiceArgs.value.serviceId);
    }
}

// Private

pure circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "midnames:did:pk"), sk]);
}

circuit deactivate(): [] {
    active = false;
}

circuit addKey(key: PublicKey): [] {
    const d_key = disclose(key);
    assert(!keyRing.member(d_key.id), "Cannot repeat Key id");
    keyRing.insert(d_key.id, d_key);
}

circuit removeKey(keyId: Opaque<"string">): [] {
    const d_keyId = disclose(keyId);
    assert(keyRing.member(disclose(keyId)), "Key is not in KeyRing");
    keyRing.remove(d_keyId);
}

circuit addAllowedUsage(keyId: Opaque<"string">, actionType: ActionType): [] {
    assert(keyRing.member(disclose(keyId)), "Key is not in KeyRing");

    const d_key = keyRing.lookup(disclose(keyId));
    const d_actionType = disclose(actionType);

    if (d_actionType == ActionType.Authentication) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, authentication: true }
        });
    } else if (d_actionType == ActionType.AssertionMethod) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, assertionMethod: true }
        });
    } else if (d_actionType == ActionType.KeyAgreement) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, keyAgreement: true }
        });
    } else if (d_actionType == ActionType.CapabilityInvocation) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, capabilityInvocation: true }
        });
    } else if (d_actionType == ActionType.CapabilityDelegation) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, capabilityDelegation: true }
        });
    }
}

circuit removeAllowedUsage(keyId: Opaque<"string">, actionType: ActionType): [] {
    assert(keyRing.member(disclose(keyId)), "Key is not in KeyRing");

    const d_key = keyRing.lookup(disclose(keyId));
    const d_actionType = disclose(actionType);

    if (d_actionType == ActionType.Authentication) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, authentication: false }
        });
    } else if (d_actionType == ActionType.AssertionMethod) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, assertionMethod: false }
        });
    } else if (d_actionType == ActionType.KeyAgreement) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, keyAgreement: false }
        });
    } else if (d_actionType == ActionType.CapabilityInvocation) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, capabilityInvocation: false }
        });
    } else if (d_actionType == ActionType.CapabilityDelegation) {
        keyRing.insert(d_key.id, PublicKey{ ...d_key,
            allowedUsages: AllowedUsages{ ...d_key.allowedUsages, capabilityDelegation: false }
        });
    }
}

circuit addService(service: Service): [] {
    const d_service = disclose(service);
    assert(!services.member(d_service.id), "Cannot repeat Service id");
    services.insert(d_service.id, d_service);
}

circuit removeService(serviceId: Opaque<"string">): [] {
    const d_serviceId = disclose(serviceId);
    assert(keyRing.member(disclose(serviceId)), "Service is not in Services Set");
    services.remove(d_serviceId);
}